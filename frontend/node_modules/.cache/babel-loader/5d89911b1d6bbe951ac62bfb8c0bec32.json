{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSPropertySignature = TSPropertySignature;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSThisType = TSThisType;\nexports.TSFunctionType = TSFunctionType;\nexports.TSConstructorType = TSConstructorType;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.TSTypeReference = TSTypeReference;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nexports.tsPrintBraced = tsPrintBraced;\nexports.TSArrayType = TSArrayType;\nexports.TSTupleType = TSTupleType;\nexports.TSOptionalType = TSOptionalType;\nexports.TSRestType = TSRestType;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSUnionType = TSUnionType;\nexports.TSIntersectionType = TSIntersectionType;\nexports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;\nexports.TSConditionalType = TSConditionalType;\nexports.TSInferType = TSInferType;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSMappedType = TSMappedType;\nexports.TSLiteralType = TSLiteralType;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSImportType = TSImportType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction TSTypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nfunction TSTypeParameter(node) {\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.token(\".\");\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\";\");\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.token(\"]\");\n  }\n\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nfunction TSMethodSignature(node) {\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSIndexSignature(node) {\n  const {\n    readonly\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n\n  this._parameters(node.parameters, node);\n\n  this.token(\"]\");\n  this.print(node.typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\n\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\n\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\n\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\n\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\n\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\n\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\n\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\n\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\n\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\n\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\n\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\n\nfunction TSThisType() {\n  this.word(\"this\");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters,\n    parameters\n  } = node;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.typeAnnotation.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n\n  this.print(node.parameterName);\n\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  this.tsPrintBraced(members, node);\n}\n\nfunction tsPrintBraced(members, node) {\n  this.token(\"{\");\n\n  if (members.length) {\n    this.indent();\n    this.newline();\n\n    for (const member of members) {\n      this.print(member, node);\n      this.newline();\n    }\n\n    this.dedent();\n    this.rightBrace();\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType, node);\n  this.token(\"[]\");\n}\n\nfunction TSTupleType(node) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, node);\n  this.token(\"]\");\n}\n\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.token(\"?\");\n}\n\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType, node);\n}\n\nfunction TSUnionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"|\");\n}\n\nfunction TSIntersectionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(node, sep) {\n  this.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n\n  });\n}\n\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nfunction TSParenthesizedType(node) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.token(\"{\");\n  this.space();\n\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAsExpression(node) {\n  const {\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, node);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation, node);\n  this.token(\">\");\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tsPrintBraced(members, node);\n}\n\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\",\");\n}\n\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.token(\";\");\n    return;\n  }\n\n  let body = node.body;\n\n  while (body.type === \"TSModuleDeclaration\") {\n    this.token(\".\");\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  this.tsPrintBraced(node.body, node);\n}\n\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument, node);\n  this.token(\")\");\n\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier, node);\n  }\n\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference, node);\n  this.token(\";\");\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.token(\"!\");\n}\n\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression, node);\n  this.token(\";\");\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters,\n    parameters\n  } = node;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction tsPrintClassMemberModifiers(node, isField) {\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}","map":{"version":3,"sources":["/Users/patrick/Desktop/Learn/Projects/3-bcnMin-v3/client/node_modules/@babel/generator/lib/generators/typescript.js"],"names":["Object","defineProperty","exports","value","TSTypeAnnotation","TSTypeParameterDeclaration","TSTypeParameterInstantiation","TSTypeParameter","TSParameterProperty","TSDeclareFunction","TSDeclareMethod","TSQualifiedName","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","TSPropertySignature","tsPrintPropertyOrMethodName","TSMethodSignature","TSIndexSignature","TSAnyKeyword","TSBigIntKeyword","TSUnknownKeyword","TSNumberKeyword","TSObjectKeyword","TSBooleanKeyword","TSStringKeyword","TSSymbolKeyword","TSVoidKeyword","TSUndefinedKeyword","TSNullKeyword","TSNeverKeyword","TSIntrinsicKeyword","TSThisType","TSFunctionType","TSConstructorType","tsPrintFunctionOrConstructorType","TSTypeReference","TSTypePredicate","TSTypeQuery","TSTypeLiteral","tsPrintTypeLiteralOrInterfaceBody","tsPrintBraced","TSArrayType","TSTupleType","TSOptionalType","TSRestType","TSNamedTupleMember","TSUnionType","TSIntersectionType","tsPrintUnionOrIntersectionType","TSConditionalType","TSInferType","TSParenthesizedType","TSTypeOperator","TSIndexedAccessType","TSMappedType","TSLiteralType","TSExpressionWithTypeArguments","TSInterfaceDeclaration","TSInterfaceBody","TSTypeAliasDeclaration","TSAsExpression","TSTypeAssertion","TSEnumDeclaration","TSEnumMember","TSModuleDeclaration","TSModuleBlock","TSImportType","TSImportEqualsDeclaration","TSExternalModuleReference","TSNonNullExpression","TSExportAssignment","TSNamespaceExportDeclaration","tsPrintSignatureDeclarationBase","tsPrintClassMemberModifiers","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","node","token","space","optional","print","typeAnnotation","printList","params","word","name","constraint","accessibility","readonly","_param","parameter","declare","_functionHead","_classMethodHead","left","right","initializer","computed","_parameters","parameters","typeParameters","typeName","asserts","parameterName","exprName","members","length","indent","newline","member","dedent","rightBrace","elementType","elementTypes","label","sep","printJoin","types","separator","checkType","extendsType","trueType","falseType","typeParameter","operator","objectType","indexType","nameType","tokenIfPlusMinus","self","tok","literal","expression","id","extends","extendz","body","const","isConst","global","type","argument","qualifier","isExport","moduleReference","isField","static","abstract"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSPropertySignature = TSPropertySignature;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSThisType = TSThisType;\nexports.TSFunctionType = TSFunctionType;\nexports.TSConstructorType = TSConstructorType;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.TSTypeReference = TSTypeReference;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nexports.tsPrintBraced = tsPrintBraced;\nexports.TSArrayType = TSArrayType;\nexports.TSTupleType = TSTupleType;\nexports.TSOptionalType = TSOptionalType;\nexports.TSRestType = TSRestType;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSUnionType = TSUnionType;\nexports.TSIntersectionType = TSIntersectionType;\nexports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;\nexports.TSConditionalType = TSConditionalType;\nexports.TSInferType = TSInferType;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSMappedType = TSMappedType;\nexports.TSLiteralType = TSLiteralType;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSImportType = TSImportType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction TSTypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nfunction TSTypeParameter(node) {\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.token(\".\");\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\";\");\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.token(\"]\");\n  }\n\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nfunction TSMethodSignature(node) {\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSIndexSignature(node) {\n  const {\n    readonly\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n\n  this._parameters(node.parameters, node);\n\n  this.token(\"]\");\n  this.print(node.typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\n\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\n\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\n\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\n\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\n\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\n\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\n\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\n\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\n\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\n\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\n\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\n\nfunction TSThisType() {\n  this.word(\"this\");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters,\n    parameters\n  } = node;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.typeAnnotation.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n\n  this.print(node.parameterName);\n\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  this.tsPrintBraced(members, node);\n}\n\nfunction tsPrintBraced(members, node) {\n  this.token(\"{\");\n\n  if (members.length) {\n    this.indent();\n    this.newline();\n\n    for (const member of members) {\n      this.print(member, node);\n      this.newline();\n    }\n\n    this.dedent();\n    this.rightBrace();\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType, node);\n  this.token(\"[]\");\n}\n\nfunction TSTupleType(node) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, node);\n  this.token(\"]\");\n}\n\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.token(\"?\");\n}\n\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType, node);\n}\n\nfunction TSUnionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"|\");\n}\n\nfunction TSIntersectionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(node, sep) {\n  this.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n\n  });\n}\n\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nfunction TSParenthesizedType(node) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.token(\"{\");\n  this.space();\n\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAsExpression(node) {\n  const {\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, node);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation, node);\n  this.token(\">\");\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tsPrintBraced(members, node);\n}\n\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\",\");\n}\n\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.token(\";\");\n    return;\n  }\n\n  let body = node.body;\n\n  while (body.type === \"TSModuleDeclaration\") {\n    this.token(\".\");\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  this.tsPrintBraced(node.body, node);\n}\n\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument, node);\n  this.token(\")\");\n\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier, node);\n  }\n\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference, node);\n  this.token(\";\");\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.token(\"!\");\n}\n\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression, node);\n  this.token(\";\");\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters,\n    parameters\n  } = node;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction tsPrintClassMemberModifiers(node, isField) {\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}"]},"metadata":{},"sourceType":"script"}