{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","map":{"version":3,"sources":["/Users/patrick/Desktop/Learn/Projects/3-bcnMin-v3/client/node_modules/@babel/traverse/lib/context.js"],"names":["Object","defineProperty","exports","value","default","_path","_interopRequireDefault","require","t","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","testing","process","env","NODE_ENV","TraversalContext","constructor","scope","opts","state","parentPath","queue","priorityQueue","shouldVisit","node","enter","exit","type","keys","VISITOR_KEYS","length","create","listKey","parent","container","maybeQueue","path","notPriority","trap","Error","push","visitMultiple","visitQueue","visitSingle","visited","WeakSet","stop","resync","contexts","pushContext","add","visit","popContext","nodes","Array","isArray"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;"]},"metadata":{},"sourceType":"script"}