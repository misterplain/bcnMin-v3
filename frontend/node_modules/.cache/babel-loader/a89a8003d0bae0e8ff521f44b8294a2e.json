{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.File = File;\nexports.Program = Program;\nexports.BlockStatement = BlockStatement;\nexports.Noop = Noop;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter, node);\n  }\n\n  this.print(node.program, node);\n}\n\nfunction Program(node) {\n  this.printInnerComments(node, false);\n  this.printSequence(node.directives, node);\n  if (node.directives && node.directives.length) this.newline();\n  this.printSequence(node.body, node);\n}\n\nfunction BlockStatement(node) {\n  var _node$directives;\n\n  this.token(\"{\");\n  this.printInnerComments(node);\n  const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n\n  if (node.body.length || hasDirectives) {\n    this.newline();\n    this.printSequence(node.directives, node, {\n      indent: true\n    });\n    if (hasDirectives) this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.removeTrailingNewline();\n    this.source(\"end\", node.loc);\n    if (!this.endsWith(\"\\n\")) this.newline();\n    this.rightBrace();\n  } else {\n    this.source(\"end\", node.loc);\n    this.token(\"}\");\n  }\n}\n\nfunction Noop() {}\n\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}\n\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw != null) {\n    this.token(raw);\n    return;\n  }\n\n  const {\n    value\n  } = node;\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\"Malformed AST: it is not possible to print a directive containing\" + \" both unescaped single and double quotes.\");\n  }\n}\n\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}\\n`);\n}\n\nfunction Placeholder(node) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}","map":{"version":3,"sources":["/Users/patrick/Desktop/Learn/Projects/3-bcnMin-v3/client/node_modules/@babel/generator/lib/generators/base.js"],"names":["Object","defineProperty","exports","value","File","Program","BlockStatement","Noop","Directive","DirectiveLiteral","InterpreterDirective","Placeholder","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","node","program","print","interpreter","printInnerComments","printSequence","directives","length","newline","body","_node$directives","token","hasDirectives","indent","removeTrailingNewline","source","loc","endsWith","rightBrace","semicolon","unescapedSingleQuoteRE","unescapedDoubleQuoteRE","raw","getPossibleRaw","test","Error","name","expectedNode"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.File = File;\nexports.Program = Program;\nexports.BlockStatement = BlockStatement;\nexports.Noop = Noop;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter, node);\n  }\n\n  this.print(node.program, node);\n}\n\nfunction Program(node) {\n  this.printInnerComments(node, false);\n  this.printSequence(node.directives, node);\n  if (node.directives && node.directives.length) this.newline();\n  this.printSequence(node.body, node);\n}\n\nfunction BlockStatement(node) {\n  var _node$directives;\n\n  this.token(\"{\");\n  this.printInnerComments(node);\n  const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n\n  if (node.body.length || hasDirectives) {\n    this.newline();\n    this.printSequence(node.directives, node, {\n      indent: true\n    });\n    if (hasDirectives) this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.removeTrailingNewline();\n    this.source(\"end\", node.loc);\n    if (!this.endsWith(\"\\n\")) this.newline();\n    this.rightBrace();\n  } else {\n    this.source(\"end\", node.loc);\n    this.token(\"}\");\n  }\n}\n\nfunction Noop() {}\n\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}\n\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw != null) {\n    this.token(raw);\n    return;\n  }\n\n  const {\n    value\n  } = node;\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\"Malformed AST: it is not possible to print a directive containing\" + \" both unescaped single and double quotes.\");\n  }\n}\n\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}\\n`);\n}\n\nfunction Placeholder(node) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}"]},"metadata":{},"sourceType":"script"}