{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.skipAllButComputedKey = skipAllButComputedKey;\nexports.default = exports.environmentVisitor = void 0;\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar _helperMemberExpressionToFunctions = _interopRequireDefault(require(\"@babel/helper-member-expression-to-functions\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = t.cloneNode(objectRef);\n  const targetRef = isStatic || isPrivateMethod ? objectRef : t.memberExpression(objectRef, t.identifier(\"prototype\"));\n  return t.callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}\n\nconst environmentVisitor = {\n  [`${t.staticBlock ? \"StaticBlock|\" : \"\"}ClassPrivateProperty|TypeAnnotation`](path) {\n    path.skip();\n  },\n\n  Function(path) {\n    if (path.isMethod()) return;\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n  },\n\n  \"Method|ClassProperty\"(path) {\n    skipAllButComputedKey(path);\n  }\n\n};\nexports.environmentVisitor = environmentVisitor;\n\nconst visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n\n}]);\n\nconst unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n\n}]);\n\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return t.cloneNode(property);\n    }\n\n    return t.stringLiteral(property.name);\n  },\n\n  get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(superMember, thisRefs) {\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n\n  _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: t.thisExpression()\n      };\n    }\n\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: t.assignmentExpression(\"=\", thisRef, t.thisExpression()),\n      this: t.cloneNode(thisRef)\n    };\n  },\n\n  set(superMember, value) {\n    const thisRefs = this._getThisRefs();\n\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, t.booleanLiteral(superMember.isInStrictMode())]);\n  },\n\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n\n  call(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, true);\n  }\n\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    return t.cloneNode(property);\n  },\n\n  get(superMember) {\n    const {\n      isStatic,\n      superRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n\n    if (isStatic) {\n      object = superRef ? t.cloneNode(superRef) : t.memberExpression(t.identifier(\"Function\"), t.identifier(\"prototype\"));\n    } else {\n      object = superRef ? t.memberExpression(t.cloneNode(superRef), t.identifier(\"prototype\")) : t.memberExpression(t.identifier(\"Object\"), t.identifier(\"prototype\"));\n    }\n\n    return t.memberExpression(object, prop, computed);\n  },\n\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.assignmentExpression(\"=\", t.memberExpression(t.thisExpression(), prop, computed), value);\n  },\n\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.memberExpression(t.thisExpression(), prop, computed);\n  },\n\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, true);\n  }\n\n});\n\nclass ReplaceSupers {\n  constructor(opts) {\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static;\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.superRef = opts.superRef;\n    this.isLoose = opts.isLoose;\n    this.opts = opts;\n  }\n\n  getObjectRef() {\n    return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  replace() {\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n\n    const handler = this.isLoose ? looseHandlers : specHandlers;\n    (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      superRef: this.superRef\n    }, handler));\n  }\n\n}\n\nexports.default = ReplaceSupers;","map":{"version":3,"sources":["/Users/patrick/Desktop/Learn/Projects/3-bcnMin-v3/client/node_modules/@babel/helper-replace-supers/lib/index.js"],"names":["Object","defineProperty","exports","value","skipAllButComputedKey","default","environmentVisitor","_traverse","_interopRequireDefault","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","t","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","cloneNode","targetRef","memberExpression","identifier","callExpression","addHelper","path","node","computed","skip","keys","VISITOR_KEYS","type","skipKey","staticBlock","Function","isMethod","isArrowFunctionExpression","visitor","visitors","merge","Super","state","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","property","memo","maybeGenerateMemoised","memoiser","prop","stringLiteral","_get","_getThisRefs","thisRefs","proto","getObjectRef","sequenceExpression","this","isDerivedConstructor","thisExpression","thisRef","generateDeclaredUidIdentifier","assignmentExpression","booleanLiteral","isInStrictMode","destructureSet","buildCodeFrameError","args","optionalCall","looseHandlers","assign","superRef","ReplaceSupers","constructor","opts","methodPath","isClassMethod","kind","isObjectMethod","static","isPrivate","isLoose","replace","refToPreserve","traverse","handler","bind"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.skipAllButComputedKey = skipAllButComputedKey;\nexports.default = exports.environmentVisitor = void 0;\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar _helperMemberExpressionToFunctions = _interopRequireDefault(require(\"@babel/helper-member-expression-to-functions\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = t.cloneNode(objectRef);\n  const targetRef = isStatic || isPrivateMethod ? objectRef : t.memberExpression(objectRef, t.identifier(\"prototype\"));\n  return t.callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}\n\nconst environmentVisitor = {\n  [`${t.staticBlock ? \"StaticBlock|\" : \"\"}ClassPrivateProperty|TypeAnnotation`](path) {\n    path.skip();\n  },\n\n  Function(path) {\n    if (path.isMethod()) return;\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n  },\n\n  \"Method|ClassProperty\"(path) {\n    skipAllButComputedKey(path);\n  }\n\n};\nexports.environmentVisitor = environmentVisitor;\n\nconst visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n\n}]);\n\nconst unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n\n}]);\n\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return t.cloneNode(property);\n    }\n\n    return t.stringLiteral(property.name);\n  },\n\n  get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(superMember, thisRefs) {\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n\n  _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: t.thisExpression()\n      };\n    }\n\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: t.assignmentExpression(\"=\", thisRef, t.thisExpression()),\n      this: t.cloneNode(thisRef)\n    };\n  },\n\n  set(superMember, value) {\n    const thisRefs = this._getThisRefs();\n\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, t.booleanLiteral(superMember.isInStrictMode())]);\n  },\n\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n\n  call(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, true);\n  }\n\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    return t.cloneNode(property);\n  },\n\n  get(superMember) {\n    const {\n      isStatic,\n      superRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n\n    if (isStatic) {\n      object = superRef ? t.cloneNode(superRef) : t.memberExpression(t.identifier(\"Function\"), t.identifier(\"prototype\"));\n    } else {\n      object = superRef ? t.memberExpression(t.cloneNode(superRef), t.identifier(\"prototype\")) : t.memberExpression(t.identifier(\"Object\"), t.identifier(\"prototype\"));\n    }\n\n    return t.memberExpression(object, prop, computed);\n  },\n\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.assignmentExpression(\"=\", t.memberExpression(t.thisExpression(), prop, computed), value);\n  },\n\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.memberExpression(t.thisExpression(), prop, computed);\n  },\n\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, true);\n  }\n\n});\n\nclass ReplaceSupers {\n  constructor(opts) {\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static;\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.superRef = opts.superRef;\n    this.isLoose = opts.isLoose;\n    this.opts = opts;\n  }\n\n  getObjectRef() {\n    return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  replace() {\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n\n    const handler = this.isLoose ? looseHandlers : specHandlers;\n    (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      superRef: this.superRef\n    }, handler));\n  }\n\n}\n\nexports.default = ReplaceSupers;"]},"metadata":{},"sourceType":"script"}